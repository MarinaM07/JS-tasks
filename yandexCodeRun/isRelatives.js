/* Пример размножения клетки местной «амёбы» AGGC:
AGGC > AGGC, AGGC, AAGGC, GAGGC, TAGGC, CAGGC, AGGCA, AGGCG, AGGCT, AGGCC 

 Для двух случайно взятых клеток определите, можно ли считать их родственниками.
Клетки считаются родственниками со степенью родства N, если ДНК их общего предка порождает любую
из ДНК исходных клеток не более чем за N мутаций. Общий предок видов — ДНК клетки, среди потомков
которой есть клетки с ДНК как первого вида, так и второго. Все клетки имеют в составе ДНК нуклеотиды,
пустых цепочек не существует.

 Примеры
AT и TA
AT и TA — родственники со степенью родства 1:

у вида AT нашелся родитель A через одно поколение (то есть A — предок по крайней мере одной клетки
с ДНК AT), цепочка мутаций A -> AT;
у вида TA тоже нашелся родитель A через одно поколение, цепочка мутаций A -> TA.
В данном случае можно было найти также предка с ДНК T.

ATGGC и TG
ATGGC и TG — родственники со степенью родства 3:

TG — общий предок видов ATGGC и TG;

среди потомков TG есть сама клетка TG, 0 мутаций
среди потомков TG есть ATGGC, 3 мутации: TG -> ATG -> ATGG -> ATGGC
Клетка TG порождает клетки с ДНК ATGGC и TG не более чем за 3 мутации. ATGGC и TG — также родственники
со степенью родства 4, 5 и т.д., так как условие «не более чем за 3 мутации» обобщается и на большие
степени.

AAA и AAA
AAA и AAA — родственники со степенью родства 0.

G и T
При любой степени проверяемого родства они не родственники, так как нет общего предка
(клетки с пустой ДНК не существует).

Условие
Напишите функцию, которая принимает ДНК двух клеток и проверяемую степень родства,
и возращает булево значение: true, если клетки являются родственниками с нужной степенью родства,
или false, если не являются
*/

export function isRelativies(genA, genB, level) {
    // Вычисление длин строк
    const n = genA.length;
    const m = genB.length;
    
    // Вычисляем минимальную требуемую длину P
    const minLenA = Math.max(0, n - level);
    const minLenB = Math.max(0, m - level);
    const minRequired = Math.max(minLenA, minLenB, 1);
    
    // Если minRequired больше минимальной длины строк, родства нет
    if (minRequired > Math.min(n, m)) {
        return false;
    }
    
    // DP для поиска общей подстроки
    let dp = Array.from({length: n + 1}, () => Array(m + 1).fill(0));
    let found = false;
    
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (genA[i - 1] === genB[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] >= minRequired) {
                    found = true;
                    // Можно прервать, но для простоты продолжаем
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }
    
    return found;
}

/* 1. Инициализация
    Вычисление длин строк
        const n = genA.length;
        const m = genB.length;
    
    Вычисление минимальной требуемой длины предковой цепочки P
        const minLenA = Math.max(0, n - level);
        const minLenB = Math.max(0, m - level);
        const minRequired = Math.max(minLenA, minLenB, 1);

    Мутации здесь — это только добавление нуклеотидов в начало или конец цепочки
    (не замена или вставка внутри).
    Минимальная требуемая длина предковой цепочки minRequired вычисляется как
    Math.max(minLenA, minLenB, 1), где minLenA = Math.max(0, len(genA) - level) и аналогично для genB,
    чтобы minRequired была достаточно длинной для достижения обеих цепочек не более чем level мутациями
    (добавлениями в начало или конец). Это предотвращает случаи, где короткая minRequired требует
    слишком многих мутаций, и если minRequired > Math.min(len(genA), len(genB)), родства нет,
    так как такую общую подстроку найти невозможно.

    2. Проверка на невозможность родства

        if (minRequired > Math.min(n, m)) {
            return false;
       
       Если minRequired больше минимальной длины из n и m, то невозможно найти общую подстроку
       такой длины (ведь подстрока не может быть длиннее самой короткой строки). В этом случае
       сразу возвращаем false.
       
    3. Инициализация динамического программирования (DP) для поиска общей подстроки
    
        for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= m; j++) {
            if (genA[i - 1] === genB[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] >= minRequired) {
                    found = true;
                    // Можно прервать, но для простоты продолжаем
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }

    - Внешний цикл по i от 1 до n: перебираем позиции в genA.
    - Внутренний цикл по j от 1 до m: перебираем позиции в genB.
    - Для каждой пары позиций (i, j):
        -Проверяем, равны ли символы genA[i-1] и genB[j-1] (индексы начинаются с 0, поэтому i-1).
        -Если равны (например, оба 'A'), то dp[i][j] = dp[i-1][j-1] + 1. Это значит, что длина общей
        подстроки увеличивается на 1 по сравнению с предыдущей диагональной клеткой.
        -Если не равны, dp[i][j] = 0 (сбрасываем, потому что подстрока прерывается).
        - После обновления dp[i][j] проверяем, >= ли она minRequired. Если да, устанавливаем
        found = true.


    4. Возврат результата
        return found;

    * dp[0][1] — это значение для i=0 (genA пуста) и j=1 (genB[0]='T'). Поскольку одна из строк пустая,
    общая подстрока невозможна, поэтому инициализация dp[0][j] = 0 для всех j (стандарт для границ
    таблицы).
     Когда символы совпадают (genA[0]='A' и genB[1]='A'), мы берём значение из диагональной
    предыдущей ячейки dp[0][1] = 0 (длина предыдущей подстроки, заканчивающейся на пустой
    genA и genB[0]).
     Затем добавляем +1, потому что текущий совпадающий символ 'A' расширяет эту подстроку.
    Поскольку предыдущая длина 0, результат 0 + 1 = 1 — это означает, что мы начинаем новую
    подстроку длины 1: "A".
     Без +1 мы бы просто копировали предыдущую
    длину (0), игнорируя совпадение, что неверно для непрерывной подстроки.    
*/