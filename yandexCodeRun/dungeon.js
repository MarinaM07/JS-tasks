/* Нужно реализовать метод scan, который принимает на вход карту - матрицу NxM,
состоящую только из 1 и 0. И возвращает объект с количеством каждого типа образования 
{ceil:0, floor:0, both:0}. 
Если образование свисает с потолка и не касается пола – ceil
Если образование растет от пола и не касается потолка – floor
Если образование свисает с потолка и при этом еще и касается пола – both.
 1. Пример:
[
  [1, 0, 1],
  [1, 1, 1],
  [0, 0, 0],
]
[
  [1, 0, 1],
  [1, 1, 1],
  [0, 0, 0],
]
Результат: {ceil: 1, floor: 0, both: 0}

 2. Пример:
[
  [1, 0, 1],
  [1, 1, 1],
  [0, 0, 1],
]
[
  [1, 0, 1],
  [1, 1, 1],
  [0, 0, 1],
]
Результат: {ceil: 0, floor: 0, both: 1}

Считаем, что по диагонали образования не пересекаются:
[
  [1, 0, 1],
  [0, 1, 0],
]
[
  [1, 0, 3],
  [0, 2, 0],
]
Результат: {ceil: 2, floor: 1, both: 0}.*/

export function scan(map) {
    if (!map || map.length === 0) {
        return { ceil: 0, floor: 0, both: 0 };
    }

    const N = map.length; //количество строк (высота сетки)
    const M = map[0].length; //количество столбцов (ширина сетки)
    const visited = Array.from({ length: N }, () => Array(M).fill(false)); 
    //Создаётся двумерный массив visited размером N x M, заполненный false
    let ceilCount = 0;
    let floorCount = 0;
    let bothCount = 0;

    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

    for (let i = 0; i < N; i++) {
        for (let j = 0; j < M; j++) {
            if (map[i][j] === 1 && !visited[i][j]) {
                const queue = [[i, j]];
                visited[i][j] = true;
                let touchesCeil = i === 0;
                let touchesFloor = i === N - 1;

                while (queue.length > 0) {
                    const [x, y] = queue.shift();

                    for (const [dx, dy] of directions) {
                        const nx = x + dx;
                        const ny = y + dy;

                        if (nx >= 0 && nx < N && ny >= 0 && ny < M && map[nx][ny] === 1 && !visited[nx][ny]) {
                            visited[nx][ny] = true;
                            queue.push([nx, ny]);

                            if (nx === 0) touchesCeil = true;
                            if (nx === N - 1) touchesFloor = true;
                        }
                    }
                }

                if (touchesCeil && touchesFloor) {
                    bothCount++;
                } else if (touchesCeil) {
                    ceilCount++;
                } else {
                    floorCount++;
                }
            }
        }
    }

    return { ceil: ceilCount, floor: floorCount, both: bothCount };
}

/* 
1. Начальная проверка и инициализация.

Если карта (map) не существует, пуста или имеет нулевую длину, функция сразу возвращает объект с нулями:
{ ceil: 0, floor: 0, both: 0 }. Это предотвращает ошибки при работе с пустыми данными.
ceil — компоненты, касающиеся только верхней границы (потолка).
floor — компоненты, касающиеся только нижней границы (пола).
both — компоненты, касающиеся и верхней, и нижней границы одновременно.

N — количество строк (высота сетки).
M — количество столбцов (ширина сетки). Предполагается, что все строки имеют одинаковую длину.

const visited = Array.from({ length: N }, () => Array(M).fill(false));

Создаётся двумерный массив visited размером N x M, заполненный false.
Он используется для отслеживания, какие клетки уже были посещены во время обхода.
Это предотвращает повторный анализ одной и той же клетки.

let ceilCount = 0;
let floorCount = 0;
let bothCount = 0;

Инициализируются счётчики для трёх типов компонент

const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];

Массив направлений для обхода соседей: вверх ([-1, 0]), вниз ([1, 0]),
влево ([0, -1]), вправо ([0, 1]). Это 4-направленный обход (без диагоналей).

2. Основной цикл по клеткам сетки

for (let i = 0; i < N; i++) {
    for (let j = 0; j < M; j++) {
        if (map[i][j] === 1 && !visited[i][j]) {
            // ... BFS для новой компоненты
        }
    }
}
Два вложенных цикла проходят по каждой клетке сетки (от i=0 до N-1, от j=0 до M-1).
Если клетка map[i][j] === 1 (занятая) и ещё не посещена (!visited[i][j]), то начинается
обход новой компоненты связности с помощью BFS (Breadth-First Search — поиск в ширину).

3. BFS для обхода компоненты

const queue = [[i, j]];
visited[i][j] = true;
let touchesCeil = i === 0;
let touchesFloor = i === N - 1;

Создаётся очередь queue, в которую добавляется начальная клетка [i, j].
Клетка помечается как посещённая (visited[i][j] = true).
Инициализируются флаги:
touchesCeil — true, если начальная клетка находится на верхней границе (i === 0).
touchesFloor — true, если начальная клетка находится на нижней границе (i === N - 1).

while (queue.length > 0) {
    const [x, y] = queue.shift();
    
    for (const [dx, dy] of directions) {
        const nx = x + dx;
        const ny = y + dy;
        ...

Пока очередь не пуста:
Извлекается текущая клетка [x, y] из очереди.
Для каждого из 4 направлений вычисляется новая позиция [nx, ny].
Проверяется, что новая клетка:
В пределах сетки (nx >= 0 && nx < N && ny >= 0 && ny < M).
Содержит 1 (map[nx][ny] === 1).
Ещё не посещена (!visited[nx][ny]).
Если условия выполнены:
Клетка помечается как посещённая.
Добавляется в очередь для дальнейшего обхода.
Проверяется, касается ли она границ: если nx === 0, устанавливается touchesCeil = true;
если nx === N - 1, устанавливается touchesFloor = true.
Этот процесс продолжает обход всей компоненты: все связанные клетки с 1 будут посещены,
и флаги обновятся, если компонента касается границ.

4. Классификация компоненты

if (touchesCeil && touchesFloor) {
    bothCount++;
} else if (touchesCeil) {
    ceilCount++;
} else {
    floorCount++;
}

После обхода компоненты проверяются флаги:
Если касается и потолка, и пола (touchesCeil && touchesFloor), увеличивается bothCount.
Иначе, если касается только потолка (touchesCeil), увеличивается ceilCount.
Иначе (если касается только пола или вообще не касается границ), увеличивается floorCount. 

5. Возврат результата

return { ceil: ceilCount, floor: floorCount, both: bothCount };

*/