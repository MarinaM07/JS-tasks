/*Даны два отсортированных массива nums1 И nums2, нужно поместить все элементы nums2 в nums1 так,
чтобы элементы итоговоого массива остались отсортированными. Формат ввода
[46,55,88,0,0,0,0] 3 [18,29,80,90] 4

Примечание
- количество элементов в массивах nums1 и nums2 равны m и n соотвественно;
- можно считать, что в массиве nums1 зарезервированно место для всех элементов (n + m) 
и заполнены нулями;
- результат должен сохраниться в переменной nums1, результат функции явно возвращать не обязательно.*/
/**
 * @param {number[]} nums1 - первый отсортированный массив
 * @param {number} m - количество значимых элементов в nums1
 * @param {number[]} nums2 - второй отсортированный массив
 * @param {number} n - количество элементов в nums2
 * @return {void} Не возвращайте ничего, вместо этого модифицируйте nums1.
 */
export function merge(nums1, m, nums2, n) {
    let i = m - 1;
    let j = n - 1;
    let k = m + n - 1;

    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k] = nums1[i];
            i--;
        }
        else {
            nums1[k] = nums2[j];
            j--;
        }
        k--;
    }
    while (j >= 0) {
        nums1[k] = nums2[j];
        j--;
        k--;
    }

}

/*Двухуказательный подход с слиянием с конца массива, чтобы избежать дополнительной памяти и перезаписи
элементов.
Время: O(m + n) — линейное, так как каждый элемент обрабатывается ровно один раз. 
Память: O(1). Плюсы: Оптимален по времени, особенно для больших массивов. Использует отсортированность 
входных данных.

Мы сливаем массивы с конца, чтобы не перезаписывать элементы nums1 преждевременно 
(нули в конце nums1 служат буфером). 
Основной цикл: while (i >= 0 && j >= 0) 
Этот цикл продолжается, пока есть элементы в обоих массивах. 
Второй цикл: while (j >= 0) Если в nums2 остались элементы (nums1 уже обработан),
копируем их в начало результирующего массива (слева направо, но поскольку k двигается назад,
это заполняет оставшиеся позиции).*/