/* Активность офиса
    Легенда:
    В Яндексе — самом технологичном и креативном офисе страны — каждый день кипит жизнь. Команды запускают новые сервисы, аналитики шутят
    про бигдату, менеджеры спешат на встречи, а иногда в кабинетах звучит музыка или разгорается корпоратив! Ваша задача — стать
    «невидимой Метрикой» для их офиса: по заданной схеме этажей (матрица, где каждая ячейка — это отдельное помещение) и истории событий
    (например, встречи, шутки, музыка или корпоратив) вычислить, где сейчас самая яркая активность. Изменения происходят постоянно:
    где-то внезапно гаснет свет, где-то зажигается лампа, в одном кабинете собрались сотрудники пошутить, в другом включили трек
    с Яндекс Музыки, а в переговорке отмечают релиз нового сервиса. Вам надо учесть все эти перемены и вычислить то помещение, где градус
    событий наибольший. Помещения в офисе индексируются следующим образом: строки нумеруются снизу вверх (1 — самая нижняя строка),
    столбцы — слева направо (1 — первый слева). Например, «3.2» — это третья снизу строка и второй столбец слева.

    Описание:
    Дана матрица N x M, представляющая собой представление офиса. Каждая ячейка матрицы соответствует помещению в офисе, а значение
    в каждой ячейке представляет собой тип активности в данный момент времени. Ваша цель — отследить эту активность и найти помещения
    с самой большой активностью. Если активности не было, то необходимо вернуть null. Если активности были, то необходимо вернуть номер
    помещения с максимальной активностью, если таких помещений несколько, то вернуть номер с наименьшим номером строки и столбца.

    Входные данные:
    office: матрица размером N x M целых чисел (от 0 до 6), представляющая начальное состояние помещения: 0: свет выключен, людей не видно; 1: свет горит, людей не видно; 2: свет выключен, человек в помещении; 3: свет включен, человек в помещении; 4: шутят шутки; 5: включили музыку; 6: устроили корпоратив. history: история изменения помещения — список размером W, описывающий изменения состояния каждого помещения офиса. Каждый элемент содержит номер помещения и изменения состояния (целое число).
    history: История изменения помещения -- список размером W, описывающий изменения состояния каждого помещения офиса. Каждый элемент
    содержит номер помещения и изменения состояния (целое число).
    Примеры:
    office: [[0, 0, 0], [0, 0, 1], [2, 3, 0]]

    ___________                         _________________
    | 0 | 0 | 0 |                       | 3.1 | 3.2 | 3.3 |
    | 0 | 0 | 1 |           ->          | 2.1 | 2.2 | 2.3 |   
    | 2 | 3 | 0 |                       | 1.1 | 1.2 | 1.3 |
    history: [["3.1", 4], ["2.2", 5], ["3.2", 6]]

    В ответе нужно вернуть "3.2".

    Также активности могут суммироваться, например [["2.1", 4], ["2.1", 1]] -> в "2.1" будет активность 5.

    Вывод:
    Номер помещения с масимальной активностью.

    Ограничения: N и M (3 ≤ N, M ≤ 20), представляющие размеры офиса. W (0 ≤ W ≤ 50) — количество изменений.

*/

function solution(office, history) {
    const N = office.length;
    const M = office[0].length;

    // Создаем копию офиса для итоговых активностей
    const final = office.map(row => [...row]);

    // Обрабатываем историю изменений
    const changes = {};
    for (const [room, delta] of history) {
        if (!changes[room]) changes[room] = 0;
        changes[room] += delta;
    }

    // Применяем изменения к final
    for (const room in changes) {
        const [rStr, cStr] = room.split('.');
        const r = parseInt(rStr);
        const c = parseInt(cStr);
        // Индексы в массиве: row_index = N - r, col_index = c - 1
        const rowIdx = N - r;
        const colIdx = c - 1;
        final[rowIdx][colIdx] += changes[room];
    }

    // Находим максимальную активность
    let maxActivity = -1;
    let bestRoom = null;

    for (let r = 1; r <= N; r++) {
        for (let c = 1; c <= M; c++) {
            const rowIdx = N - r;
            const colIdx = c - 1;
            const activity = final[rowIdx][colIdx];
            if (activity > maxActivity) {
                maxActivity = activity;
                bestRoom = `${r}.${c}`;
            } else if (activity === maxActivity) {
                // Сравниваем по номеру столбца (меньший c), затем по строке (больший r для верхней строки)
                const [currR, currC] = bestRoom.split('.').map(Number);
                if (c < currC || (c === currC && r > currR)) {
                    bestRoom = `${r}.${c}`;
                }
            }
        }
    }

    // Если максимальная активность 0, возвращаем null
    return maxActivity === 0 ? null : bestRoom;
}

/*module.exports = solution;*/

/* Входные данные:

    office: Матрица (массив массивов) размером N x M, где N — строки (3 ≤ N ≤ 20), M — столбцы (3 ≤ M ≤ 20). Каждая ячейка — целое
        число от 0 до 6, представляющее начальную активность помещения (0: ничего, 1: свет, 2: человек без света, и т.д.).
    history: Список (массив) размером W (0 ≤ W ≤ 50) пар [номер_помещения, изменение], где:
        - номер_помещения — строка вида "r.c" (r — номер строки снизу вверх, 1 — самая нижняя; c — номер столбца слева направо,
          1 — самый левый).
        - изменение — целое число (может быть положительным, отрицательным или нулевым), которое добавляется к активности помещения.

    Индексация помещений:

    Матрица office в коде индексирована как стандартный массив: office[0] — верхняя строка (соответствует r = N), office[N-1] — нижняя
     строка (r = 1).
    Для помещения "r.c": реальный индекс в массиве — rowIdx = N - r, colIdx = c - 1.

    Цель:

    - применить все изменения из history к копии office (активности суммируются, если несколько изменений для одного помещения).
    - найти помещение с максимальной итоговой активностью.
    - если максимальная активность > 0, вернуть номер помещения с максимумом (если несколько — выбрать с наименьшим номером строки, затем
        столбца).
    - если максимальная активность ≤ 0 (т.е. все активности 0 или меньше), вернуть null.

    1. Инициализация размеров матрицы.
        const N = office.length;
        const M = office[0].length;
            N — количество строк в office (высота матрицы).
            M — количество столбцов в office (длина каждой строки).

    2. Создание копии офиса для итоговых активностей.
        - final — глубокая копия office (массив массивов). Мы не изменяем оригинальный office, а работаем с копией.
        - map(row => [...row]) создаёт новый массив, где каждая строка копируется (чтобы изменения не затрагивали оригинал).
        Почему копия? Потому что мы будем применять изменения из history к final, но начальные значения из office должны остаться.

    3. Обработка истории изменений (суммирование дельт).
        - changes — объект (словарь), где ключ — строка room (например, "3.1"), значение — сумма всех delta для этого помещения.
        - цикл проходит по каждому элементу history (массив пар [room, delta]).
        - если для room ещё нет ключа, инициализируем 0, затем добавляем delta.
        Это обрабатывает суммирование: если несколько изменений для одного помещения, они складываются.

    4. Применение изменений к final.
        - цикл по ключам changes (помещениям, где были изменения).
        - разбираем room: split('.') даёт [rStr, cStr], преобразуем в числа r и c.
        - вычисляем индексы массива:
            - rowIdx = N - r: Потому что r=1 (нижняя строка) → rowIdx = N-1 (последняя строка массива), r=N (верхняя) → rowIdx=0.
            - colIdx = c - 1: c=1 (левый столбец) → colIdx=0, c=M → colIdx=M-1.
        - добавляем changes[room] к final[rowIdx][colIdx].
        Пример: Для "3.1" (r=3, c=1), N=3, rowIdx=3-3=0, colIdx=1-1=0 → final[0][0] += 4 (было 0, стало 4).

    5. Поиск максимальной активности и помещения.
        - maxActivity — текущий максимум (инициализирован -1, чтобы первое помещение всегда обновляло).
        - bestRoom — строка с номером лучшего помещения.
        - внешний цикл: r от 1 до N (строки снизу вверх).
        - внутренний цикл: c от 1 до M (столбцы слева направо).
        - для каждого помещения: вычисляем activity из final.
        - если activity > maxActivity, обновляем maxActivity и bestRoom на ${r}.${c}.
        - если activity === maxActivity, сравниваем:
            - сначала по c
            - если c равны, то по r (т.е. верхняя строка).
            
    6. Возвращение результата.
    
        return maxActivity === 0 ? null : bestRoom;
*/

