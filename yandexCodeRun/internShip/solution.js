/* Модель событий

    На вход приходит модель событий некоторой страницы, элементы которой представляют собой кастомные сущности (элементы), описывающие
    текущую страницу — они выдуманы. К примеру, предположим, что мы разрабатываем конструктор сайта, где пользователи не знают ничего
    про HTML, но могут описать страницу набором ограниченных ключей. Каждый конечный ключ возвращает функцию, ассоциированную с данной
    сущностью (событие).

    Пример модели:

    const MODEL = {
        page: {
            content: {
                form: {
                    submit: someFunc1,
                },
                infoBlock: {
                    more: {
                        click: someFunc2,
                    },
                },
            },
            footer: {
                blog: {
                    about: {
                        expand: someFunc3,
                    },
                    articles: {
                        click: someFunc4,
            },
                },
                show: someFunc5,
            },
            header: {
                logo: someFunc6,
                user: {
                    login: someFunc7,
                    logout: someFunc8,
                },
            },
            show: someFunc9,
        },
    };

    ЗАДАЧА
    Напишите функцию, которая обрабатывает текущую модель и возвращает новый объект типа «композитный ключ/новая функция»,
    где новая функция — это функция, которая возвращает результат изначальной функции с переданным композитным ключом в качестве
    параметра. Композитный ключ — это ключ, который представляет собой перечисление вложенных ключей модели через точку. К примеру:

    page.content.form.submit

    или

    page.content.infoBlock.more.click
    и так далее.

    Соответственно, ответ будет выглядеть как объект, например:

    {
    page.content.form.submit: someNewFunction1,
    page.content.infoBlock.more.click: someNewFunction2,
    
    // и так далее
    }

*/

function solution(root) {
    const result = {};

    function traverse(obj, path) {
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const currentPath = path.concat(key);
                if (typeof obj[key] === 'function') {
                    const compositeKey = currentPath.join('.');
                    result[compositeKey] = function() {
                        return obj[key](compositeKey);
                    };
                } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                    traverse(obj[key], currentPath);
                }
            }
        }
    }

    traverse(root, []);
    return result;
}

/*module.exports = solution;*/

/*  Функция solution(root) получает вложенный объект root (как дерево). Она рекурсивно проходит по нему, находит все функции
и создаёт новый объект result. В result ключи — это строки-пути к функциям (например, "a.b.func"), а значения — анонимные обёртки.
Когда обёртку вызывают, она запускает оригинальную функцию и передаёт ей этот путь как аргумент.

    1. Создаем пустой объект. Он будет заполняться по мере обхода.
    
    2. Создаем вспомогательную функцию function traverse. Она рекурсивная и отвечает за обход объекта.
        Параметры:
            - obj: текущий объект, который обходим.
            - path: массив строк, представляющий путь от корня до текущего объекта (например, ['page', 'content', 'form','submit'] для пути
            "page.content.form.submit").
    
    3. Цикл for..in.
        Цикл собирает все ключи в объекте obj.
        if (obj.hasOwnProperty(key)): проверка, что ключ — собственное свойство объекта, а не унаследованное от прототипа.
        Это важно, чтобы избежать обработки свойств из Object.prototype (например, toString).

        const currentPath = path.concat(key);
        Заполняем массив path ключами, добавляя ключ в конец.

        Далее проверяем тип obj[key]. Если это функция, то: typeof возвращает строку 'function' для функций.
    
        
    4. Создание составного ключа и добавление в result

        compositeKey = currentPath.join('.'). Массив currentPath (например, ['a', 'b', 'func']) соединяется в строку с точками,
        получая 'a.b.func'. Это и есть путь как ключ

        result[compositeKey] = function() { ... }, в result добавляется новое свойство с ключом compositeKey.
        Значение — анонимная функция. Эта функция, когда вызывается, делает return obj[key](compositeKey);
        она вызывает оригинальную функцию obj[key] и передаёт ей compositeKey (путь) как аргумент. Возвращает результат оригинальной
        функции. Важно: obj[key] — это ссылка на оригинальную функцию, так что она остаётся связанной с исходным контекстом
        (если функция использует this, это может быть проблемой, но в коде это не учитывается).

    5. Проверка, является ли значение объектом (для рекурсии).

        Если значение не функция, проверяем, является ли оно объектом.

        if (typeof obj[key] === 'object' && obj[key] !== null) {
                    traverse(obj[key], currentPath);
                }

        typeof obj[key] === 'object': даёт true для объектов (включая массивы, но код не обрабатывает массивы специально).
        && obj[key] !== null: исключает null, так как typeof null === 'object', но null не объект для обхода.
        Если да, то рекурсивно обходим вложенный объект.

    6. Вызов traverse для корневого объекта.

        После определения traverse вызывается traverse(root, []) — обход начинается с root и пустого пути [].
        Пустой массив означает, что мы на корневом уровне.

    7. Возврат результата.
*/